#define ADVANCED_TIME_MEASUREMENT

using System;
using System.Collections.Generic;
using System.IO;
using System.Numerics;
using Ab4d.SharpEngine.Common;
using Ab4d.SharpEngine.Effects;
using Ab4d.SharpEngine.Materials;
using Ab4d.SharpEngine.Meshes;
using Ab4d.SharpEngine.Core;
using Ab4d.SharpEngine.SceneNodes;
using Ab4d.SharpEngine.Utilities;
using Cyotek.Drawing.BitmapFont;
using Material = Ab4d.SharpEngine.Materials.Material;
using Ab4d.Vulkan;

namespace Ab4d.SharpEngine.Samples.Utilities
{
    //
    // ******** BitmapFont generation ******** 
    //
    // Download the "Bitmap font generator" from https://www.angelcode.com/products/bmfont/ (or use any other bitmap font (.fnt) file generator)

    // - In "Export options" use "White text with alpha" preset and use 32 bit depth
    // - For better quality when scaling it is very good that the font texture has mip-maps (see internet for more into about mip-maps).
    //   Because mip-maps are scaled down versions of the original image, the font must be rendered with padding to prevent that
    //   pixels from sibling characters would affect the scaled down mip-maps. It is not needed to provide all mip-map levels (to 1x1 bitmap).
    //   But it is recommended to provide mip-maps until the mip-map where each character is 8x8 pixels big.
    //   Each mip-map requires to double the padding, for example:
    //   - for texture with character size 64 pixels: if we provide 8px padding, we can use 3 mip-maps: 32x32, 16x16, 8x8
    //   - for texture with character size 128 pixels: if we provide 16px padding, we can use 4 mip-maps: 64x64, 32x32, 16x16, 8x8
    //   BitmapTextCreator will read the padding and create the mip maps based on the padding value.
    // - Note that when creating 8 bit png bitmap with "Bitmap font generator" does not correctly create a alpha-transparent bitmap. 
    //   Therefore it is better to store into 32 bit bitmap and then use some third-party imaging tool to convert to 8-bit png with proper transparency.

    // Advanced bitmap font generation:
    // 1) When generating bitmap font with standard latin and extended latin or other characters, the "Bitmap font generator" may produce more then one page
    //    and in this case it will shuffle characters across many texture pages. This means that even if only standard characters are used,
    //    multiple GeometryModels with multiple textures may be needed to show the text.
    //    To prevent that it is good to fist create a bitmap font with only standard latin characters. This will render all standard character to one bitmap.
    //    Then render other characters to another font file (.fnt file). Open the other .fnt file and increase the page number by 1 (replace "page=2" with "page=3"; then "page=1" with "page=2", ...)
    //    Then open the first .fnt file and increase the number of characters count (sum chars count from both files).
    //    Then copy the line that stars with "page" from the other file to the first fnt file (after the first page).
    //    Then copy the char data from the other fnt file to the first fnt file (before the kernings part). Save the file. 
    //    This will create a merged fnt file where all standard latin chars will be in one texture, but in cases when other characters are required, then multiple textures will be used.
    //
    //    Another simpler solution is also to increase the bitmap size (for example to 2048x2048 for 128 font size). But this has slightly slower performance as a bigger texture need to be present on the GPU.
    //
    // 2) When automatically creating mip-maps with SharpEngine, the smaller mips are generated by simple downsizing. 
    //    It is possible to generate a better quality mips with using some third party tool like Photoshop and provide custom mips to the BitmapTextCreator.
    //    This does not provide significant 

    public class BitmapTextCreator : IDisposable
    {
        private readonly Scene? _scene;

        private readonly Cyotek.Drawing.BitmapFont.BitmapFont _bitmapFont;

        private readonly IBitmapIO? _bitmapIO;
        private readonly Func<string, RawImageData>? _bitmapLoader;

        private readonly GpuImage?[] _fontPages;
        private SolidColorEffect? _solidColorEffect;


        public BitmapFont BitmapFont => _bitmapFont;

        /// <summary>
        /// Gets or sets a Boolean that specifies if font kerning is used (different distance between characters may be used based on the two characters).
        /// </summary>
        public bool IsKerningUsed { get; set; } = true;

        /// <summary>
        /// Gets or sets a Boolean that specifies if the same font material is also set to the BackMaterial property of the GeometryModel3D.
        /// </summary>
        public bool IsTwoSided { get; set; } = true;

        /// <summary>
        /// Gets or sets additional space after each character.
        /// </summary>
        public float AdditionalCharacterSpace { get; set; }

        /// <summary>
        /// Gets or sets additional space after each line.
        /// </summary>
        public float AdditionalLineSpace { get; set; }

        /// <summary>
        /// Gets or sets a character that is displayed in case the character in the specified text is not defined in the bitmap font.
        /// By default the UnknownChar is set to space. When UnknownChar is set to null char ('\0') that means that the unknown character is skipped (current position is not changed).
        /// </summary>
        public char UnknownChar { get; set; } = ' ';

        /// <summary>
        /// Gets or sets a float that specifies at which alpha value the pixel will be skipped in the fragment shader. Default value is 0.1.
        /// </summary>
        public float AlphaClipThreshold { get; set; } = 0.1f;

        /// <summary>
        /// When CustomMaterialProvider is set, it is used to create the material for the specified font page index.
        /// If CustomMaterialProvider is null or if it returns null, then the material is created by the BitmapTextCreator.
        /// </summary>
        public Func<int, Material>? CustomMaterialProvider { get; set; }

        /// <summary>
        /// When CustomMipMapBitmapProvider is set, then the Func is called to get the custom mip-map bitmaps.
        /// The first parameter is texture file name for the current page, the second parameter is page index and the third parameter is mip level (0 for original bitmap).
        /// If this Func is not set, then mip-maps are generated by Vulkan.
        /// </summary>
        public Func<string, int, int, RawImageData>? CustomMipMapBitmapProvider { get; set; }

#if ADVANCED_TIME_MEASUREMENT
        public static double FontImageLoadTimeMs;
        public static double FontGpuImageCreateTimeMs;
#endif

        public BitmapTextCreator(Scene? scene, BitmapFont bitmapFont, IBitmapIO bitmapIO)
        {
            _scene = scene;
            _bitmapFont = bitmapFont;
            _bitmapIO = bitmapIO;
            _bitmapLoader = null;

            _fontPages = new GpuImage[bitmapFont.Pages.Length];
        }

        public BitmapTextCreator(Scene? scene, BitmapFont bitmapFont, Func<string, RawImageData> bitmapLoader)
        {
            _scene = scene;
            _bitmapFont = bitmapFont;
            _bitmapLoader = bitmapLoader;
            _bitmapIO = null;

            _fontPages = new GpuImage[bitmapFont.Pages.Length];
        }


        public SceneNode CreateTextNode(string text,
                                        Vector3 position,
                                        PositionTypes positionType,
                                        Vector3 textDirection,
                                        Vector3 upDirection,
                                        float fontSize,
                                        Color4 textColor,
                                        bool isSolidColorMaterial = false,
                                        string? name = null)
        {
            CreateOrMeasureTextNode(text: text,
                                    topLeftPosition: new Vector3(0, 0, 0),
                                    textDirection: new Vector3(1, 0, 0), // we need to set textDirection to x axis ..
                                    upDirection: new Vector3(0, 1, 0),   // and upDirection to y axis to correctly measure text size
                                    fontSize: fontSize,
                                    textColor: Color4.Black,
                                    isSolidColorMaterial: false,
                                    createTextNode: false,
                                    nodeName: null,
                                    sceneNode: out _,
                                    textPosition: out var textPosition,
                                    textSize: out var textSize);

            var centerPosition = MathUtils.GetCenterPosition(position, positionType, textDirection, upDirection, textSize);

            textDirection = Vector3.Normalize(textDirection);
            upDirection = Vector3.Normalize(upDirection);

            var topLeftPosition = centerPosition - (0.5f * textSize.X + textPosition.X) * textDirection + (0.5f * textSize.Y - (textPosition.Y + textSize.Y)) * upDirection;

            CreateOrMeasureTextNode(text, topLeftPosition, textDirection, upDirection, fontSize, textColor, isSolidColorMaterial, createTextNode: true, nodeName: name, out var sceneNode, out _, out _);
            return sceneNode!;
        }

        public Vector2 GetTextSize(string text, float fontSize)
        {
            CreateOrMeasureTextNode(text: text,
                                    topLeftPosition: new Vector3(0, 0, 0),
                                    textDirection: new Vector3(1, 0, 0), // we need to set textDirection to x axis ..
                                    upDirection: new Vector3(0, 1, 0),   // and upDirection to y axis to correctly measure text size
                                    fontSize: fontSize,
                                    textColor: Color4.Black,
                                    isSolidColorMaterial: false,
                                    createTextNode: false,
                                    nodeName: null,
                                    sceneNode: out _,
                                    textPosition: out _,
                                    textSize: out var textSize);

            return textSize;
        }

        private void CreateOrMeasureTextNode(string text,
                                             Vector3 topLeftPosition,
                                             Vector3 textDirection, // needs to be normalized
                                             Vector3 upDirection,   // needs to be normalized
                                             float fontSize,
                                             Color4 textColor,
                                             bool isSolidColorMaterial,
                                             bool createTextNode,
                                             string? nodeName,
                                             out SceneNode? sceneNode,
                                             out Vector2 textPosition,
                                             out Vector2 textSize)
        {
            if (_scene == null || string.IsNullOrEmpty(text))
            {
                if (createTextNode)
                    sceneNode = new MeshModelNode(); // return empty GeometryModel3D
                else
                    sceneNode = null;

                textSize = new Vector2(0, 0);
                textPosition = new Vector2(0, 0);

                return;
            }


            List<Vector3>? positions;
            List<Vector2>? textureCoordinates;
            List<MeshModelNode>? allTextModelNodes;

            if (createTextNode)
            {
                positions = new List<Vector3>();
                textureCoordinates = new List<Vector2>();
                allTextModelNodes = new List<MeshModelNode>();
            }
            else
            {
                positions = null;
                textureCoordinates = null;
                allTextModelNodes = null;
            }

            float minX = float.MaxValue;
            float minY = float.MaxValue;
            float maxX = float.MinValue;
            float maxY = float.MinValue;

            float fontScale = fontSize / (float)_bitmapFont.BaseHeight;

            // Multiply by fontScale so we can remove multiplying in the code below
            textDirection *= fontScale;
            upDirection *= fontScale;

            if (_bitmapFont.StretchedHeight != 100) // 100 mean no stretch (100%)
                textDirection *= 100.0f / (float)_bitmapFont.StretchedHeight; // we do not increase the font size (because user specified the required size) but reduce the font width: textDirection *= 1 / ((float)bitmapFont.StretchedHeight / 100.0f); 


            float textureWidthFactor = 1.0f / (float)_bitmapFont.TextureSize.Width;
            float textureHeightFactor = 1.0f / (float)_bitmapFont.TextureSize.Height;

            int horizontalPadding = _bitmapFont.Padding.Left + _bitmapFont.Padding.Right;
            int verticalPadding = _bitmapFont.Padding.Top + _bitmapFont.Padding.Bottom;

            var spaceCharacterData = _bitmapFont.Characters[' '];


            // font can be defined in multiple pages (texture). Go through all pages...
            for (int pageIndex = 0; pageIndex < _bitmapFont.Pages.Length; pageIndex++)
            {
                var currentPosition = topLeftPosition;
                var lineStartPosition = topLeftPosition;

                char previousCharacter = ' ';
                int renderedCharacters = 0;

                bool isFirstCharInLine = true;

                for (int i = 0; i < text.Length; i++)
                {
                    var oneChar = text[i];

                    if (oneChar == '\n')
                    {
                        currentPosition = lineStartPosition - (_bitmapFont.LineHeight + AdditionalLineSpace) * upDirection;
                        lineStartPosition = currentPosition;
                        isFirstCharInLine = true;
                        continue;
                    }

                    if ((int)oneChar < (int)32) // Skip special chars
                        continue;

                    Cyotek.Drawing.BitmapFont.Character oneCharData;
                    if (!_bitmapFont.Characters.TryGetValue(oneChar, out oneCharData))
                    {
                        if (UnknownChar == '\0') // When _unknownChar is '\0' then unknown char is skipped
                            continue;

                        if (!_bitmapFont.Characters.TryGetValue(UnknownChar, out oneCharData))
                            continue; // UH: Cannot find _unknownChar
                    }

                    if (oneChar == ' ') // space only advances the position
                    {
                        currentPosition += textDirection * (spaceCharacterData.XAdvance + AdditionalCharacterSpace);
                        continue;
                    }


                    int kerning = IsKerningUsed ? _bitmapFont.GetKerning(previousCharacter, oneChar) : 0;

                    if (isFirstCharInLine && oneCharData.XOffset + kerning < 0)
                    {
                        // If first character in line has negative X offset, this means that it would rendered to the left of the left border
                        // To prevent that we need to move the currentPosition to the right so that when XOffset will be used it will move use right to the left border
                        currentPosition -= textDirection * (oneCharData.XOffset + kerning);
                    }

                    if (oneCharData.TexturePage == pageIndex) // If this character is using another TexturePage, then do not add it to this SceneNode (because another texture is required)
                    {
                        var dx = textDirection * (oneCharData.Width - _bitmapFont.Padding.Left - _bitmapFont.Padding.Right);
                        var dy = upDirection * (oneCharData.Height - _bitmapFont.Padding.Top - _bitmapFont.Padding.Bottom);

                        var charPosition = currentPosition + textDirection * (oneCharData.XOffset + kerning + _bitmapFont.Padding.Left) + upDirection * (_bitmapFont.Padding.Top - oneCharData.YOffset);

                        if (createTextNode)
                        {
                            positions!.Add(charPosition - dy);
                            positions.Add(charPosition + dx - dy);
                            positions.Add(charPosition + dx);
                            positions.Add(charPosition);


                            var texturePos = new Vector2((float)(oneCharData.X + _bitmapFont.Padding.Left) * textureWidthFactor, (float)(oneCharData.Y + _bitmapFont.Padding.Top) * textureHeightFactor);
                            var tdx = (float)(oneCharData.Width - horizontalPadding) * textureWidthFactor;
                            var tdy = (float)(oneCharData.Height - verticalPadding) * textureHeightFactor;

                            textureCoordinates!.Add(new Vector2(texturePos.X, texturePos.Y + tdy));
                            textureCoordinates.Add(new Vector2(texturePos.X + tdx, texturePos.Y + tdy));
                            textureCoordinates.Add(new Vector2(texturePos.X + tdx, texturePos.Y));
                            textureCoordinates.Add(new Vector2(texturePos.X, texturePos.Y));
                        }
                        else
                        {
                            minX = Math.Min(minX, charPosition.X);
                            minY = Math.Min(minY, charPosition.Y - dy.Y);

                            maxX = Math.Max(maxX, charPosition.X + dx.X);
                            maxY = Math.Max(maxY, charPosition.Y);
                        }

                        renderedCharacters++;
                    }

                    currentPosition += textDirection * (oneCharData.XAdvance + _bitmapFont.OutlineSize + AdditionalCharacterSpace);

                    previousCharacter = oneChar;
                    isFirstCharInLine = false;
                }

                if (renderedCharacters == 0)
                    continue; // no character in this page; continue with the next font page


                if (!createTextNode)
                    continue; // if we just measure the size, then we can skip the following code

                var normalVector = Vector3.Cross(textDirection, upDirection);

                var positionsCount = positions!.Count;

                var vertexBufferArray = new PositionNormalTextureVertex[positionsCount];
                for (int i = 0; i < positionsCount; i++)
                {
                    vertexBufferArray[i].Position = positions[i];
                    vertexBufferArray[i].Normal = normalVector;
                    vertexBufferArray[i].TextureCoordinate = textureCoordinates![i];
                }

                // Clear positions and texture coordinates to prepare space for next pages (if any)
                positions.Clear();
                textureCoordinates!.Clear();


                var triangleIndices = new int[renderedCharacters * 6];

                int currentPositionIndex = 0;
                for (int i = 0; i < renderedCharacters; i++)
                {
                    int indiceIndex = i * 6;

                    triangleIndices[indiceIndex + 0] = currentPositionIndex;
                    triangleIndices[indiceIndex + 1] = currentPositionIndex + 1;
                    triangleIndices[indiceIndex + 2] = currentPositionIndex + 2;

                    triangleIndices[indiceIndex + 3] = currentPositionIndex + 0;
                    triangleIndices[indiceIndex + 4] = currentPositionIndex + 2;
                    triangleIndices[indiceIndex + 5] = currentPositionIndex + 3;

                    currentPositionIndex += 4;
                }


                var planeMesh = new StandardMesh(vertexBufferArray, triangleIndices, (nodeName ?? "") + "TextPlaneMesh");


                EnsureFontPage(pageIndex);
                var materialName = (_bitmapFont.FamilyName ?? "") + "_FontTexture_" + pageIndex.ToString();

                Material? fontMaterial;

                if (CustomMaterialProvider != null)
                    fontMaterial = CustomMaterialProvider(pageIndex);
                else
                    fontMaterial = null;

                if (fontMaterial == null)
                {
                    var fontTexture = _fontPages[pageIndex];
                    if (fontTexture != null)
                    {
                        var standardFontMaterial = new StandardMaterial(fontTexture, CommonSamplerTypes.Clamp, name: materialName);
                        standardFontMaterial.AlphaClipThreshold = this.AlphaClipThreshold;
                        standardFontMaterial.DiffuseColor = textColor.ToColor3();
                        standardFontMaterial.Opacity = textColor.Alpha;

                        if (isSolidColorMaterial)
                        {
                            if (_solidColorEffect == null)
                                _solidColorEffect = _scene.EffectsManager.GetDefault<SolidColorEffect>();

                            standardFontMaterial.Effect = _solidColorEffect;
                        }

                        fontMaterial = standardFontMaterial;
                    }
                    else
                    {
                        fontMaterial = StandardMaterials.Red;
                    }
                }

                // Uncomment teh following line to see mesh for each character:
                //fontMaterial = StandardMaterials.Green;

                var textModelNode = new MeshModelNode(planeMesh, fontMaterial, nodeName);

                if (this.IsTwoSided)
                    textModelNode.BackMaterial = fontMaterial;

                allTextModelNodes!.Add(textModelNode);
            }

            if (createTextNode)
            {
                if (allTextModelNodes!.Count == 0)
                {
                    sceneNode = new MeshModelNode();
                }
                else if (allTextModelNodes.Count == 1)
                {
                    sceneNode = allTextModelNodes[0];
                }
                else
                {
                    // When we need more font texture pages, we need more MeshModelNodes and in this case we create a new GroupNode
                    var groupNode = new GroupNode(nodeName);

                    for (var i = 0; i < allTextModelNodes.Count; i++)
                        groupNode.Add(allTextModelNodes[i]);

                    sceneNode = groupNode;
                }

                textPosition = new Vector2(0, 0);
                textSize = new Vector2(0, 0);
            }
            else
            {
                // measure text
                textPosition = new Vector2(minX, minY);
                textSize = new Vector2(maxX - Math.Min(minX, 0), Math.Max(maxY, 0) - minY);

                sceneNode = null;
            }
        }

        private void EnsureFontPage(int pageIndex)
        {
            if (_scene == null || _fontPages[pageIndex] != null || _scene.GpuDevice == null)
                return;

            string fileName = _bitmapFont.Pages[pageIndex].FileName;

#if ADVANCED_TIME_MEASUREMENT
            var startTime = DateTime.Now;
#endif

        RawImageData imageData;

            if (_bitmapLoader != null)
            {
                imageData = _bitmapLoader(fileName);
            }
            else if (_bitmapIO != null)
            {
                try
                {
                    imageData = _bitmapIO.LoadBitmap(fileName);
                }
                catch (FileNotFoundException)
                {
                    throw new FileNotFoundException($"Texture file for bitmap font for page {pageIndex} does not exist: {fileName ?? "<null>"}");
                }
            }
            else
            {
                throw new InvalidOperationException("No texture loader provided");
            }

#if ADVANCED_TIME_MEASUREMENT
            var fontLoadedTime = DateTime.Now;
            FontImageLoadTimeMs += (fontLoadedTime - startTime).TotalMilliseconds;
#endif


            var name = System.IO.Path.GetFileName(fileName);


            GpuImage gpuImage;

            // If we want to use mip-mapping, then font texture needs to be created with some padding.
            // Usually we do not need to provide all mip levels, because smaller mip levels are not visible clearly,
            // but it is beneficial to provide at least a few mip levels.
            // But to prevent pixels from another character to influence color of another character, there need to be enough padding around characters:
            // 2px for 1 additional mip-level; 4px for 2 additional mip-levels, 8px for 3 additional mip-levels, 16px for 4 additional mip-levels.
            // For example for texture with character size 64 pixels: if we provide 8px padding, we can use the following mips: 32x32, 16x16, 8x8
            // For example for texture with character size 128 pixels: if we provide 16px padding, we can use the following mips: 64x64, 32x32, 16x16, 8x8
            int minPadding = Math.Min(_bitmapFont.Padding.Left, Math.Min(_bitmapFont.Padding.Bottom, Math.Min(_bitmapFont.Padding.Right, _bitmapFont.Padding.Top)));

            if (minPadding < 2)
            {
                // No mips
                gpuImage = new GpuImage(_scene.GpuDevice, imageData, generateMipMaps: false, imageSource: fileName);
            }
            else
            {
                // Generate mips based on the size of padding
                int mipsCountFromPadding = MathUtils.Log2(minPadding) + 1;
                int maxMipsCount = MathUtils.Log2(Math.Max(imageData.Width, imageData.Height)) + 1;

                int mipsCount = Math.Min(mipsCountFromPadding, maxMipsCount);

                gpuImage = new GpuImage(_scene.GpuDevice,
                                        width: imageData.Width,
                                        height: imageData.Height,
                                        format: imageData.Format,
                                        usage: ImageUsageFlags.TransferSrc | ImageUsageFlags.TransferDst | ImageUsageFlags.Sampled,
                                        memoryProperties: MemoryPropertyFlags.DeviceLocal,
                                        mipsCount: mipsCount,
                                        sampleCount: SampleCountFlags.SampleCount1,
                                        tiling: ImageTiling.Optimal,
                                        initialImageLayout: ImageLayout.Preinitialized,
                                        aspectMask: 0,
                                        createImageView: true,
                                        memorySizeAlignment: 0,
                                        name: name)
                {
                    IsPreMultipliedAlpha = imageData.IsPreMultipliedAlpha ?? false,
                    HasTransparentPixels = true
                };

                gpuImage.Source = fileName;

                if (CustomMipMapBitmapProvider != null)
                {
                    var mipsData = new byte[mipsCount][];
                    for (int i = 0; i < mipsCount; i++)
                    {
                        var rayImageData = CustomMipMapBitmapProvider(_bitmapFont.Pages[pageIndex].FileName, pageIndex, i);
                        mipsData[i] = rayImageData.Data;
                    }

                    gpuImage.CopyDataToImageMipMaps(mipsData, transitionImageToShaderReadOnlyOptimalLayout: true);
                }
                else
                {
                    // Copy data and generate mips based on the specified mips count
                    gpuImage.CopyDataToImage(imageData.Data, transitionImageToShaderReadOnlyOptimalLayout: true);
                }
            }

#if ADVANCED_TIME_MEASUREMENT
            FontGpuImageCreateTimeMs += (DateTime.Now - fontLoadedTime).TotalMilliseconds;
#endif

            _fontPages[pageIndex] = gpuImage;
        }

        public void Dispose()
        {
            for (var i = 0; i < _fontPages.Length; i++)
            {
                var oneTexture = _fontPages[i];
                if (oneTexture != null)
                    _fontPages[i] = null;
            }

            _solidColorEffect = null;
        }
    }
}