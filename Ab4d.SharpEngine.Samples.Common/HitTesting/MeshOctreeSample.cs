using System.Numerics;
using Ab4d.SharpEngine.Common;
using Ab4d.SharpEngine.Materials;
using Ab4d.SharpEngine.Meshes;
using Ab4d.SharpEngine.SceneNodes;
using Ab4d.SharpEngine.Utilities;

namespace Ab4d.SharpEngine.Samples.Common.HitTesting;

// MeshOctree is a data structure that organizes the triangles in 3D space into multiple levels of
// MeshOctreeNode objects so that the search of a triangle or a check for triangle ray intersection is very efficient.
// Each MeshOctreeNode divide its space into 8 child MeshOctreeNodes.
// See also: https://en.wikipedia.org/wiki/Octree
//
// Octrees are used in SharpEngine for very efficient hit testing of complex meshes.
// For example, when a standard hit testing is used on a 3D mesh, then the ray needs to be tested for intersection with each triangle in the mesh.
// Because meshes can have many triangles this can take a lot of time. When MeshOctree are used,
// then first the MeshOctree nodes that intersect the ray are found and then only the triangles
// in those nodes are checked for intersection with the ray.
// This massively decreases the number of required intersection tests.
//
// MeshOctree generation for hit testing (when calling GetClosestHitObject or GetAllHitObjects methods) 
// is controlled by HitTestOptions.MeshPositionsCountForOctreeGeneration property.
// This property gets or sets an integer value that specifies number of positions in a mesh
// at which an Octree is generated to speed up hit testing
// (e.g. if mesh has more positions then a value specified with this property,
// then Octree will be generated for the mesh). Default value is 512 positions.
// To disable automatic MeshOctree generation, set HitTestOptions.MeshPositionsCountForOctreeGeneration to int.MaxValue.
//
// This sample shows how to manually create an MeshOctree (this can be also done in background thread).
//
// This sample by default created 4 OcTree levels (this can be changed with MaxNodeLevels constant).
// If you have a very complex mesh, then you can increase the MaxNodeLevels constant to create more levels of the octree.
// When MeshOctree is automatically generated by Ab4d.SharpEngine, then the number of levels is defined by HitTestOptions.OctreeMaxNodeLevel property.

// The following node statistics is generated for the teapot in this example (this is generated by calling _meshOctree.GetNodeStatistics() and when ExpandChildBoundingBoxes is set to 0.2):
// Legend:
// - first node level is shown
// - how many nodes there are with actually used nodes / all possible nodes; for example (50/64 means that 50 nodes are used from all 64 nodes that would fill all the space)
// - actual bounding boxes are shown
// - Total number of triangle count in this level is shown
// - Actual number of triangles count for each used node is shown
//
// Level 1: Child nodes count: 1/1; Min BoundsSize: <100, 48.965, 62.178>; Max BoundsSize: <100, 48.965, 62.178>;  Triangles count: 0: 0
// Level 2: Child nodes count: 8/8; Min BoundsSize: <17.213, 11.451, 22.172>; Max BoundsSize: <59.937, 29.315, 37.287>;  Triangles count: 0: 0, 0, 0, 0, 0, 0, 0, 0
// Level 3: Child nodes count: 50/64; Min BoundsSize: <24.299, 0.43, 15.786>; Max BoundsSize: <28.605, 16.465, 21.867>;  Triangles count: 113: 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 51, 0, 0, 0, 0, 8, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0
// Level 4: Child nodes count: 182/512; Min BoundsSize: <2.025, 1.944, 0.219>; Max BoundsSize: <19.699, 9.275, 12.084>;  Triangles count: 3983: 4, 11, 52, 12, 8, 4, 12, 17, 76, 26, 37, 3, 8, 5, 8, 8, 13, 66, 16, 112, 35, 14, 6, 69, 21, 18, 11, 8, 15, 55, 4, 4, 12, 12, 5, 6, 6, 2, 44, 5, 35, 11, 7, 12, 1, 4, 4, 3, 2, 6, 8, 5, 8, 15, 4, 18, 19, 23, 6, 30, 53, 18, 4, 4, 12, 12, 3, 10, 4, 17, 25, 174, 7, 32, 45, 57, 7, 12, 38, 21, 77, 37, 24, 39, 23, 169, 34, 35, 65, 319, 7, 1, 2, 66, 8, 12, 3, 26, 12, 40, 42, 6, 70, 26, 4, 3, 11, 50, 12, 12, 2, 29, 48, 1, 8, 8, 8, 8, 4, 5, 3, 15, 19, 17, 9, 11, 31, 2, 7, 11, 22, 3, 2, 49, 2, 3, 33, 11, 12, 12, 1, 6, 8, 8, 6, 8, 7, 11, 8, 8, 3, 2, 2, 5, 9, 4, 8, 2, 6, 47, 2, 1, 42, 54, 1, 1, 8, 1, 1, 13, 50, 1, 287, 3, 6, 3, 4, 2, 60, 3, 1, 24
// Total triangles count: 4096 (triangle indices: 12288)
//
// For example, if the hit testing ray hits only the bounding box of the first node in the level 4, 
// then only 4 (!!!) ray-triangle hit tests are preformed (the first node in the 4th level has 4 triangles, all parent nodes do not have any triangle).
// When no MeshOctree would be used, then each hit test would need to preform 4096 ray-triangle hit test.
// In this case the performance gain is roughly 1000x !!!

public class MeshOctreeSample : CommonSample
{
    public override string Title => "Mesh Octree sample";
    public override string? Subtitle => "MeshOctree is used to significantly improve hit-testing performance.\nSee the comments in the code behind how each level of octree divides the space into 8 segments and how this reduces the number of performed ray hit tests.";

    private const int MaxNodeLevels = 4; // This should be determined by the number of triangles (more triangles bigger max level)
    
    private bool _expandChildBoundingBoxes = true;
    private bool _showActualBoundingBox = true;
    
    
    private static readonly Color4[] _nodeColors = new Color4[] { Colors.Gray, Colors.Red, Colors.Green, Colors.Blue, Colors.Black };

    
    private GroupNode _octTreeLinesGroupNode;

    private MeshOctree? _meshOctree;
    private StandardMesh? _teapotMesh;

    private ICommonSampleUIElement? _level1InfoLabel;
    private ICommonSampleUIElement? _level2InfoLabel;
    private ICommonSampleUIElement? _level3InfoLabel;
    private ICommonSampleUIElement? _level4InfoLabel;
    

    public MeshOctreeSample(ICommonSamplesContext context)
        : base(context)
    {
        _octTreeLinesGroupNode = new GroupNode("OctTeeLines");
    }

    protected override async Task OnCreateSceneAsync(Scene scene)
    {
        if (targetPositionCamera != null)
        {
            targetPositionCamera.Heading  = 30;
            targetPositionCamera.Attitude = -20;
            targetPositionCamera.Distance = 200;
        }

        scene.RootNode.Add(_octTreeLinesGroupNode);


        _teapotMesh = await base.GetCommonMeshAsync(scene, CommonMeshes.Teapot, finalSize: new Vector3(100, 100, 100));

        RecreateOctree();

        var meshModelNode = new MeshModelNode(_teapotMesh, StandardMaterials.Silver);
        scene.RootNode.Add(meshModelNode);
    }

    private void RecreateOctree()
    {
        if (_teapotMesh == null)
            return;

        float expandChildBoundingBoxes = _expandChildBoundingBoxes ? 0.2f : 0f;

        _meshOctree = _teapotMesh.CreateOctree(MaxNodeLevels, expandChildBoundingBoxes);

        ShowBoundingBoxes();

        UpdateNodeLevelInfoLabels();
        
        if (_meshOctree != null)
        {
            // Write node statistics to the debug output
            var nodeStatistics = _meshOctree.GetNodeStatistics();
            System.Diagnostics.Debug.WriteLine("Octree statistics:\n" + nodeStatistics);
        }
    }

    private void ShowBoundingBoxes()
    {
        if (_meshOctree == null || Scene == null)
            return;

        _octTreeLinesGroupNode.Clear();

        int startNodeLevel = 1;
        for (int i = startNodeLevel; i <= MaxNodeLevels; i++)
        {
            var boundingBoxes = _meshOctree.CollectBoundingBoxesInLevel(i, _showActualBoundingBox);

            foreach (var boundingBox in boundingBoxes)
            {
                var wireBoxNode = new WireBoxNode()
                {
                    Position      = boundingBox.GetCenterPosition(),
                    Size          = boundingBox.GetSize(),
                    LineColor     = _nodeColors[(i - startNodeLevel) % (_nodeColors.Length)],
                    LineThickness = 2
                };

                _octTreeLinesGroupNode.Add(wireBoxNode);
            }
        }
    }
    
    private void UpdateNodeLevelInfoLabels()
    {
        if (_meshOctree == null)
        {
            _level1InfoLabel?.SetText("1sd node level");
            _level2InfoLabel?.SetText("2nd node level");
            _level3InfoLabel?.SetText("3rd node level");
            _level4InfoLabel?.SetText("4th node level");
        }
        else
        {
            //_level1InfoLabel?.SetText($"1st node level ({_meshOctree.GetNodesCountInLevel(1)}/8 nodes)");
            //_level2InfoLabel?.SetText($"2nd node level ({_meshOctree.GetNodesCountInLevel(2)}/8 nodes)");
            //_level3InfoLabel?.SetText($"3rd node level ({_meshOctree.GetNodesCountInLevel(3)}/64 nodes)");
            //_level4InfoLabel?.SetText($"4th node level ({_meshOctree.GetNodesCountInLevel(4)}/512 nodes)");  
            
            _level1InfoLabel?.SetText($"1st node level ({_meshOctree.GetTrianglesCountInLevel(1)} triangles)");
            _level2InfoLabel?.SetText($"2nd node level ({_meshOctree.GetTrianglesCountInLevel(2)} triangles)");
            _level3InfoLabel?.SetText($"3rd node level ({_meshOctree.GetTrianglesCountInLevel(3)} triangles)");
            _level4InfoLabel?.SetText($"4th node level ({_meshOctree.GetTrianglesCountInLevel(4)} triangles)");            
        }
    }
    
    protected override void OnCreateUI(ICommonSampleUIProvider ui)
    {
        ui.CreateStackPanel(PositionTypes.Bottom | PositionTypes.Right);

        ui.CreateLabel("Legend:").SetStyle("bold");
        _level1InfoLabel = ui.CreateLabel("1st node level").SetColor(_nodeColors[0]);
        _level2InfoLabel = ui.CreateLabel("2nd node level").SetColor(_nodeColors[1]);
        _level3InfoLabel = ui.CreateLabel("3rd node level").SetColor(_nodeColors[2]);
        _level4InfoLabel = ui.CreateLabel("4th node level").SetColor(_nodeColors[3]);
        UpdateNodeLevelInfoLabels();
        
        
        ui.AddSeparator();

        ui.CreateCheckBox("Show actual bounding box (?):When checked then the actually used bounding boxes are shown (optimized to fit the child triangles).\nWhen unchecked the initial bounding boxes are shown.", 
            _showActualBoundingBox, 
            isChecked =>
            {
                _showActualBoundingBox = isChecked;
                ShowBoundingBoxes();
            });
        
        ui.CreateCheckBox("Expand BoundingBoxes (?):ExpandChildBoundingBoxes is a float that defined how much the bounding boxes of node overlap.\nBy default the value is set to 0.2 - so each bounding box is extended for 20% (but it does not go out of the parent's bounding box).\nThis way the triangles that lay on node borders will be put into the child nodes instead of having them in the parent node.", 
            _expandChildBoundingBoxes, 
            isChecked =>
            {
                _expandChildBoundingBoxes = isChecked;
                RecreateOctree();
            });
        
        
        ui.AddSeparator();

        ui.CreateLabel("See VS Output window for detailed\noctree node statistics").SetStyle("italic");
    }    
}