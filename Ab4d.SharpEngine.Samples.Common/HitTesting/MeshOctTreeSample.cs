using System.Numerics;
using Ab4d.SharpEngine.Common;
using Ab4d.SharpEngine.Materials;
using Ab4d.SharpEngine.Meshes;
using Ab4d.SharpEngine.SceneNodes;
using Ab4d.SharpEngine.Utilities;

namespace Ab4d.SharpEngine.Samples.Common.HitTesting;

// MeshOctTree is a data structure that organizes the triangles in 3D space into multiple levels of
// MeshOctTreeNode objects so that the search of a triangle or a check for triangle ray intersection is very efficient.
// Each MeshOctTreeNode divide its space into 8 child MeshOctTreeNodes.
// See also: https://en.wikipedia.org/wiki/Octree
//
// OctTrees are used in SharpEngine for very efficient hit testing of complex meshes.
// For example, when a standard hit testing is used on a 3D mesh, then the ray needs to be tested for intersection with each triangle in the mesh.
// Because meshes can have many triangles this can take a lot of time. When MeshOctTree are used,
// then first the MeshOctTree nodes that intersect the ray are found and then only the triangles
// in those nodes are checked for intersection with the ray.
// This massively decreases the number of required intersection tests.
//
// MeshOctTree generation for hit testing (when calling GetClosestHitObject or GetAllHitObjects methods) 
// is controlled by HitTestOptions.MeshPositionsCountForOctTreeGeneration property.
// This property gets or sets an integer value that specifies number of positions in a mesh
// at which an OctTree is generated to speed up hit testing
// (e.g. if mesh has more positions then a value specified with this property,
// then OctTree will be generated for the mesh). Default value is 512 positions.
// To disable automatic MeshOctTree generation, set HitTestOptions.MeshPositionsCountForOctTreeGeneration to int.MaxValue.
//
// This sample shows how to manually create an MeshOctTree (this can be also done in background thread).
//
// This sample by default created 4 OcTree levels (this can be changed with MaxNodeLevels constant).
// If you have a very complex mesh, then you can increase the MaxNodeLevels constant to create more levels of the oct tree.
// When MeshOctTree is automatically generated by Ab4d.SharpEngine, then the number of levels is defined by HitTestOptions.OctTreeMaxNodeLevel property.

// The following node statistics is generated for the teapot in this example (this is generated by calling _meshOctTree.GetNodeStatistics() and when ExpandChildBoundingBoxes is set to 0.2):
// Legend:
// - first node level is shown
// - how many nodes there are with actually used nodes / all possible nodes; for example (50/64 means that 50 nodes are used from all 64 nodes that would fill all the space)
// - actual bounding boxes are shown
// - Total number of triangle count in this level is shown
// - Actual number of triangles count for each used node is shown
//
// Level 1: Child nodes count: 1/1; Min BoundsSize: <100, 48.965, 62.178>; Max BoundsSize: <100, 48.965, 62.178>;  Triangles count: 0: 0
// Level 2: Child nodes count: 8/8; Min BoundsSize: <17.213, 11.451, 22.172>; Max BoundsSize: <59.937, 29.315, 37.287>;  Triangles count: 0: 0, 0, 0, 0, 0, 0, 0, 0
// Level 3: Child nodes count: 50/64; Min BoundsSize: <24.299, 0.43, 15.786>; Max BoundsSize: <28.605, 16.465, 21.867>;  Triangles count: 113: 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 51, 0, 0, 0, 0, 8, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0
// Level 4: Child nodes count: 182/512; Min BoundsSize: <2.025, 1.944, 0.219>; Max BoundsSize: <19.699, 9.275, 12.084>;  Triangles count: 3983: 4, 11, 52, 12, 8, 4, 12, 17, 76, 26, 37, 3, 8, 5, 8, 8, 13, 66, 16, 112, 35, 14, 6, 69, 21, 18, 11, 8, 15, 55, 4, 4, 12, 12, 5, 6, 6, 2, 44, 5, 35, 11, 7, 12, 1, 4, 4, 3, 2, 6, 8, 5, 8, 15, 4, 18, 19, 23, 6, 30, 53, 18, 4, 4, 12, 12, 3, 10, 4, 17, 25, 174, 7, 32, 45, 57, 7, 12, 38, 21, 77, 37, 24, 39, 23, 169, 34, 35, 65, 319, 7, 1, 2, 66, 8, 12, 3, 26, 12, 40, 42, 6, 70, 26, 4, 3, 11, 50, 12, 12, 2, 29, 48, 1, 8, 8, 8, 8, 4, 5, 3, 15, 19, 17, 9, 11, 31, 2, 7, 11, 22, 3, 2, 49, 2, 3, 33, 11, 12, 12, 1, 6, 8, 8, 6, 8, 7, 11, 8, 8, 3, 2, 2, 5, 9, 4, 8, 2, 6, 47, 2, 1, 42, 54, 1, 1, 8, 1, 1, 13, 50, 1, 287, 3, 6, 3, 4, 2, 60, 3, 1, 24
// Total triangles count: 4096 (triangle indices: 12288)
//
// For example, if the hit testing ray hits only the bounding box of the first node in the level 4, 
// then only 4 (!!!) ray-triangle hit tests are preformed (the first node in the 4th level has 4 triangles, all parent nodes do not have any triangle).
// When no MeshOctTree would be used, then each hit test would need to preform 4096 ray-triangle hit test.
// In this case the performance gain is roughly 1000x !!!

public class MeshOctTreeSample : CommonSample
{
    public override string Title => "Mesh OctTree sample";
    public override string? Subtitle => "MeshOctTree is used to significantly improve hit-testing performance.\nSee the comments in the code behind how each level of oct tree divides the space into 8 segments and how this reduces the number of performed ray hit tests.";

    private const int MaxNodeLevels = 4; // This should be determined by the number of triangles (more triangles bigger max level)
    
    private bool _expandChildBoundingBoxes = true;
    private bool _showActualBoundingBox = true;
    
    
    private static readonly Color4[] _nodeColors = new Color4[] { Colors.Gray, Colors.Red, Colors.Green, Colors.Blue, Colors.Black };

    
    private GroupNode _octTreeLinesGroupNode;

    private MeshOctTree? _meshOctTree;
    private StandardMesh? _teapotMesh;

    private ICommonSampleUIElement? _level1InfoLabel;
    private ICommonSampleUIElement? _level2InfoLabel;
    private ICommonSampleUIElement? _level3InfoLabel;
    private ICommonSampleUIElement? _level4InfoLabel;
    

    public MeshOctTreeSample(ICommonSamplesContext context)
        : base(context)
    {
        _octTreeLinesGroupNode = new GroupNode("OctTeeLines");
    }

    protected override void OnCreateScene(Scene scene)
    {
        scene.RootNode.Add(_octTreeLinesGroupNode);

        _teapotMesh = TestScenes.GetTestMesh(TestScenes.StandardTestScenes.Teapot, finalSize: new Vector3(100, 100, 100));

        RecreateOctTree();

        var meshModelNode = new MeshModelNode(_teapotMesh, StandardMaterials.Silver);
        scene.RootNode.Add(meshModelNode);

        if (targetPositionCamera != null)
        {
            targetPositionCamera.Heading  = 30;
            targetPositionCamera.Attitude = -20;
            targetPositionCamera.Distance = 200;
        }
    }

    private void RecreateOctTree()
    {
        if (_teapotMesh == null)
            return;

        float expandChildBoundingBoxes = _expandChildBoundingBoxes ? 0.2f : 0f;

        _meshOctTree = _teapotMesh.CreateOctTree(MaxNodeLevels, expandChildBoundingBoxes);

        ShowBoundingBoxes();

        UpdateNodeLevelInfoLabels();
        
        if (_meshOctTree != null)
        {
            // Write node statistics to the debug output
            var nodeStatistics = _meshOctTree.GetNodeStatistics();
            System.Diagnostics.Debug.WriteLine("OctTree statistics:\n" + nodeStatistics);
        }
    }

    private void ShowBoundingBoxes()
    {
        if (_meshOctTree == null || Scene == null)
            return;

        _octTreeLinesGroupNode.Clear();

        int startNodeLevel = 1;
        for (int i = startNodeLevel; i <= MaxNodeLevels; i++)
        {
            var boundingBoxes = _meshOctTree.CollectBoundingBoxesInLevel(i, _showActualBoundingBox);

            foreach (var boundingBox in boundingBoxes)
            {
                var wireBoxNode = new WireBoxNode()
                {
                    Position      = boundingBox.GetCenterPosition(),
                    Size          = boundingBox.GetSize(),
                    LineColor     = _nodeColors[(i - startNodeLevel) % (_nodeColors.Length)],
                    LineThickness = 2
                };

                _octTreeLinesGroupNode.Add(wireBoxNode);
            }
        }
    }
    
    private void UpdateNodeLevelInfoLabels()
    {
        if (_meshOctTree == null)
        {
            _level1InfoLabel?.SetText("1sd node level");
            _level2InfoLabel?.SetText("2nd node level");
            _level3InfoLabel?.SetText("3rd node level");
            _level4InfoLabel?.SetText("4th node level");
        }
        else
        {
            //_level1InfoLabel?.SetText($"1st node level ({_meshOctTree.GetNodesCountInLevel(1)}/8 nodes)");
            //_level2InfoLabel?.SetText($"2nd node level ({_meshOctTree.GetNodesCountInLevel(2)}/8 nodes)");
            //_level3InfoLabel?.SetText($"3rd node level ({_meshOctTree.GetNodesCountInLevel(3)}/64 nodes)");
            //_level4InfoLabel?.SetText($"4th node level ({_meshOctTree.GetNodesCountInLevel(4)}/512 nodes)");  
            
            _level1InfoLabel?.SetText($"1st node level ({_meshOctTree.GetTrianglesCountInLevel(1)} triangles)");
            _level2InfoLabel?.SetText($"2nd node level ({_meshOctTree.GetTrianglesCountInLevel(2)} triangles)");
            _level3InfoLabel?.SetText($"3rd node level ({_meshOctTree.GetTrianglesCountInLevel(3)} triangles)");
            _level4InfoLabel?.SetText($"4th node level ({_meshOctTree.GetTrianglesCountInLevel(4)} triangles)");            
        }
    }
    
    protected override void OnCreateUI(ICommonSampleUIProvider ui)
    {
        ui.CreateStackPanel(PositionTypes.Bottom | PositionTypes.Right);

        ui.CreateLabel("Legend:").SetStyle("bold");
        _level1InfoLabel = ui.CreateLabel("1st node level").SetColor(_nodeColors[0]);
        _level2InfoLabel = ui.CreateLabel("2nd node level").SetColor(_nodeColors[1]);
        _level3InfoLabel = ui.CreateLabel("3rd node level").SetColor(_nodeColors[2]);
        _level4InfoLabel = ui.CreateLabel("4th node level").SetColor(_nodeColors[3]);
        UpdateNodeLevelInfoLabels();
        
        
        ui.AddSeparator();

        ui.CreateCheckBox("Show actual bounding box (?):When checked then the actually used bounding boxes are shown (optimized to fit the child triangles).\nWhen unchecked the initial bounding boxes are shown.", 
            _showActualBoundingBox, 
            isChecked =>
            {
                _showActualBoundingBox = isChecked;
                ShowBoundingBoxes();
            });
        
        ui.CreateCheckBox("Expand BoundingBoxes (?):ExpandChildBoundingBoxes is a float that defined how much the bounding boxes of node overlap.\nBy default the value is set to 0.2 - so each bounding box is extended for 20% (but it does not go out of the parent's bounding box).\nThis way the triangles that lay on node borders will be put into the child nodes instead of having them in the parent node.", 
            _expandChildBoundingBoxes, 
            isChecked =>
            {
                _expandChildBoundingBoxes = isChecked;
                RecreateOctTree();
            });
        
        
        ui.AddSeparator();

        ui.CreateLabel("See VS Output window for detailed\noct tree node statistics").SetStyle("italic");
    }    
}