using Ab4d.SharpEngine.Cameras;
using Ab4d.SharpEngine.Common;
using Ab4d.SharpEngine.Core;
using Ab4d.SharpEngine.Lights;
using Ab4d.SharpEngine.Materials;
using Ab4d.SharpEngine.SceneNodes;
using Ab4d.SharpEngine.Transformations;
using Ab4d.SharpEngine.Utilities;
using System.Numerics;

namespace Ab4d.SharpEngine.Samples.Common.AdvancedModels;

public class PlanarShadowsSample : CommonSample
{
    public override string Title => "Planar Shadows";
    public override string Subtitle => "This samples shows how to create simple planar shadows that are generated by flattening the meshes to the plane.";

    private const float HalfAnimationHeight = 40f;
    private const float AnimationMinHeight = 15f;

    private bool _isShadowVisible = true;
    private bool _isTransparentMaterial = true;

    private PointLight? _shadowPointLight;
    private DirectionalLight? _shadowDirectionalLight;

    private Light? _currentShadowLight;

    private float _lightHorizontalAngle = -60;
    private float _lightVerticalAngle = 60;
    private float _lightDistance = 500;

    private GroupNode? _sampleObjectsGroupNode;
    private PlaneModelNode? _planeModelNode;

    private PlanarShadowMeshCreator? _planarShadowMeshCreator;
    private MeshModelNode? _shadowMeshModelNode;

    private PlanarShadowNode? _planarShadowNode;

    private StandardMaterial _solidShadowMaterial;
    private StandardMaterial _transparentShadowMaterial;
    
    private float _lastElapsedSeconds;
    private ICommonSampleUIElement? _clipCheckBox;


    public PlanarShadowsSample(ICommonSamplesContext context)
        : base(context)
    {
        _solidShadowMaterial = StandardMaterials.LightGray;
        _transparentShadowMaterial = new StandardMaterial(Color3.Black.ToColor4(alpha: 0.5f));
    }

    protected override async Task OnCreateSceneAsync(Scene scene)
    {
        var gpuImage = await base.GetCommonTextureAsync(scene, CommonTextures.TenByTenNumbers);

        _planeModelNode = new PlaneModelNode()
        {
            Normal = new Vector3(0, 1, 0),
            Position = new Vector3(0, -0.1f, 0),
            Size = new Vector2(400, 400),
            HeightDirection = new Vector3(0, 0, -1),
            Material = new StandardMaterial(gpuImage),
            BackMaterial = StandardMaterials.DimGray
        };

        scene.RootNode.Add(_planeModelNode);


        _sampleObjectsGroupNode = new GroupNode("SampleObjects");
        scene.RootNode.Add(_sampleObjectsGroupNode);


        // Create 10 spheres, prevent creating two spheres on the same XZ coordinates
        CreateTestSpheres();

        
        _shadowPointLight = new PointLight();
        _shadowDirectionalLight = new DirectionalLight();

        SetShadowLight(isDirectionalLight: true);

        UpdateLights();

        
        SetupPlanarShadowNode();

        UpdatePlanarShadowNode();
        
        
        // Usually the custom animation is done in the SceneUpdating event handler, that is subscribed by the following code:
        //sceneView.SceneUpdating += OnSceneViewOnSceneUpdating;
        //
        // But in this samples project we use call to CommonSample.SubscribeSceneUpdating method to subscribe to the SceneUpdating event.
        // This allows automatic unsubscribing when the sample is unloaded and automatic UI testing
        // (prevented starting animation and using CallSceneUpdating with providing custom elapsedSeconds value).
        base.SubscribeSceneUpdating(AnimateAllObjects);
        

        if (targetPositionCamera != null)
        {
            targetPositionCamera.Heading = 10;
            targetPositionCamera.Distance = 800;
            targetPositionCamera.ShowCameraLight = ShowCameraLightType.Never; // prevent adding camera's light
        }
    }

    private void SetupPlanarShadowNode()
    {
        if (Scene == null || _sampleObjectsGroupNode == null)
            return;

        if (_shadowMeshModelNode != null)
        {
            Scene.RootNode.Remove(_shadowMeshModelNode);
            _shadowMeshModelNode = null;
        }

        _planarShadowMeshCreator = null;


        var plane = new Plane(normal: new Vector3(0, 1, 0), d: 0.05f);
        _planarShadowNode = new PlanarShadowNode(plane, _sampleObjectsGroupNode);

        // Instead of setting the plane in the constructor, we can also use SetPlane method to create a plane from a PlaneModelNode
        //_planarShadowNode.SetPlane(_planeModelNode, offset: 0.05f);

        if (!_isShadowVisible)
            _planarShadowNode.Visibility = SceneNodeVisibility.Hidden;

        Scene.RootNode.Add(_planarShadowNode);
    }
    
    private void SetupPlanarShadowMeshCreator()
    {
        if (Scene == null || _sampleObjectsGroupNode == null || _planeModelNode == null)
            return;

        if (_planarShadowNode != null)
        {
            Scene.RootNode.Remove(_planarShadowNode);
            _planarShadowNode = null;
        }

        // Create PlanarShadowMeshCreator.
        // It can be used to create a planar shadow mesh.
        // This is a mesh that is created by squishing the SceneNodes specified in the PlanarShadowMeshCreator.OriginalGroupNode to the specified plane.
        // The squished mesh has zero height. The mesh can be used to create a MeshModelNode that shows the shadow (see UpdateShadowModel method below).
        _planarShadowMeshCreator = new PlanarShadowMeshCreator(_sampleObjectsGroupNode);
        _planarShadowMeshCreator.SetPlane(_planeModelNode.GetCenterPosition(), _planeModelNode.Normal, _planeModelNode.HeightDirection, _planeModelNode.Size);
        _planarShadowMeshCreator.ClipToPlane = true;

        // When MeshModelNode that shows the shadow mesh uses both front and back shadow material, we need to disable simplified normal calculation.
        // See also: https://www.ab4d.com/help/SharpEngine/html/P_Ab4d_SharpEngine_Utilities_PlanarShadowMeshCreator_SimplifyNormalCalculation.htm
        //_planarShadowMeshCreator.SimplifyNormalCalculation = false; 
    }

    private void CreateTestSpheres()
    {
        if (_sampleObjectsGroupNode == null || _planeModelNode == null)
            return;

        _sampleObjectsGroupNode.Clear();

        var spherePositions = new List<Vector3>();

        float planeCellSize = _planeModelNode.Size.X / 10;

        while (spherePositions.Count < 10)
        {
            int cellXIndex = GetRandomInt(10);
            int cellYIndex = GetRandomInt(10);

            var spherePosition = new Vector3((cellXIndex - 5) * planeCellSize + planeCellSize / 2,
                                             0,
                                             (cellYIndex - 5) * planeCellSize + planeCellSize / 2);

            // Check if this position was already taken
            if (spherePositions.Any(p => MathUtils.IsSame(p.X, spherePosition.X) && MathUtils.IsSame(p.Z, spherePosition.Z)))
                continue;

            spherePositions.Add(spherePosition);


            // t defines an animation time between 0 and 1.
            float t = GetRandomFloat();

            var sphereVisual3D = new SphereModelNode($"AnimatedSphere_{_sampleObjectsGroupNode.Count}")
            {
                CenterPosition = spherePosition,
                Radius = planeCellSize * 0.25f,
                Material = new StandardMaterial(GetRandomColor3()),
                Tag = t,
#if WEB_GL
                // Using PlanarShadowMeshCreator is very slow in the browser so reduce the number of positions there
                Segments = 10,
#endif
            };

            sphereVisual3D.Transform = new TranslateTransform(0, GetAnimatedHeight(t), 0);

            _sampleObjectsGroupNode.Add(sphereVisual3D);
        }
    }

    private void UpdatePlanarShadowNode()
    {
        if (Scene == null || _planarShadowNode == null)
            return;

        if (_currentShadowLight == _shadowDirectionalLight)
        {
            if (_shadowDirectionalLight != null)
                _planarShadowNode.ApplyDirectionalLight(_shadowDirectionalLight.Direction, updateTransformations: true);
        }
        else
        {
            if (_shadowPointLight != null)
                _planarShadowNode.ApplyPointLight(_shadowPointLight.Position, updateTransformations: true);
        }
    }

    private void UpdatePlanarShadowMeshCreator()
    {
        if (Scene == null || _planarShadowMeshCreator == null)
            return;

        // PlanarShadowMeshCreator generates a MeshGeometry3D that represents a shadow that is flattened to the plane.
        if (_currentShadowLight == _shadowDirectionalLight)
        {
            if (_shadowDirectionalLight != null)
                _planarShadowMeshCreator.ApplyDirectionalLight(_shadowDirectionalLight.Direction);
        }
        else
        {
            if (_shadowPointLight != null)
                _planarShadowMeshCreator.ApplyPointLight(_shadowPointLight.Position);
        }

        if (_shadowMeshModelNode == null)
        {
            var shadowMaterial = _isTransparentMaterial ? _transparentShadowMaterial : _solidShadowMaterial;

            _shadowMeshModelNode = new MeshModelNode(_planarShadowMeshCreator.ShadowMesh, shadowMaterial, name: "ShadowMeshNode");
            _shadowMeshModelNode.Transform = new TranslateTransform(0, 0.05f, 0); // Lift the shadow 3D model slightly above the ground

            if (!_isShadowVisible)
                _shadowMeshModelNode.Visibility = SceneNodeVisibility.Hidden;

            Scene.RootNode.Add(_shadowMeshModelNode);
        }
        else
        {
            _shadowMeshModelNode.Mesh = _planarShadowMeshCreator.ShadowMesh;
        }
    }

    private float GetAnimatedHeight(float t)
    {
        return MathF.Sin(t * MathF.PI * 2f) // make new sin cycle on each whole value of t
               * HalfAnimationHeight        // adjust result to be between -HalfAnimationHeight to +HalfAnimationHeight
               + HalfAnimationHeight        // make the result positive: between 0 and 2 * HalfAnimationHeight
               + AnimationMinHeight;        // add min height
    }

    private void AnimateAllObjects(float elapsedSeconds)
    {
        if (_sampleObjectsGroupNode == null)
            return;

        var dt = (elapsedSeconds - _lastElapsedSeconds) * 0.5f; // take 2 seconds for one animation
        _lastElapsedSeconds = elapsedSeconds;
        
        foreach (var oneSphereModelNode in _sampleObjectsGroupNode.GetAllChildren<SphereModelNode>())
        {
            if (oneSphereModelNode.Tag is not float || oneSphereModelNode.Transform is not TranslateTransform translateTransform)
                continue;

            
            var t = (float)oneSphereModelNode.Tag;
            t += dt;

            oneSphereModelNode.Tag = t;
            translateTransform.Y = GetAnimatedHeight(t);
        }

        if (_planarShadowMeshCreator != null)
        {
            _planarShadowMeshCreator.UpdateGroupNode();
            UpdatePlanarShadowMeshCreator();
        }
        else if (_planarShadowNode != null)
        {
            UpdatePlanarShadowNode();
        }
    }

    private void UpdateLights()
    {
        var position = CalculateLightPosition();

        // Create direction from position - target position = (0,0,0)
        var lightDirection = new Vector3(-position.X, -position.Y, -position.Z);
        lightDirection = Vector3.Normalize(lightDirection);

        if (_shadowPointLight != null)
            _shadowPointLight.Position = position;

        if (_shadowDirectionalLight != null)
            _shadowDirectionalLight.Direction = lightDirection;
    }

    private Vector3 CalculateLightPosition()
    {
        float xRad = _lightHorizontalAngle * MathF.PI / 180.0f;
        float yRad = _lightVerticalAngle * MathF.PI / 180.0f;

        float x = (MathF.Sin(xRad) * MathF.Cos(yRad)) * _lightDistance;
        float y = MathF.Sin(yRad) * _lightDistance;
        float z = (MathF.Cos(xRad) * MathF.Cos(yRad)) * _lightDistance;

        return new Vector3(x, y, z);
    }

    private void SetShadowLight(bool isDirectionalLight)
    {
        if (Scene == null)
            return;

        if (isDirectionalLight)
        {
            if (_currentShadowLight == _shadowDirectionalLight)
                return;

            _currentShadowLight = _shadowDirectionalLight;
        }
        else
        {
            if (_currentShadowLight == _shadowPointLight)
                return;

            _currentShadowLight = _shadowPointLight;
        }


        Scene.SetAmbientLight(0.2f);

        if (_currentShadowLight != null && !Scene.Lights.Contains(_currentShadowLight))
            Scene.Lights.Add(_currentShadowLight);
    }

    protected override void OnCreateUI(ICommonSampleUIProvider ui)
    {
        ui.CreateStackPanel(PositionTypes.Bottom | PositionTypes.Right);

        ui.CreateCheckBox("Show PlanarShadow", isInitiallyChecked: _isShadowVisible, isChecked =>
        {
            var newVisibility = isChecked ? SceneNodeVisibility.Visible : SceneNodeVisibility.Hidden;

            if (_planarShadowNode != null)
                _planarShadowNode.Visibility = newVisibility;
            
            if (_shadowMeshModelNode != null)
                _shadowMeshModelNode.Visibility = newVisibility;

            _isShadowVisible = isChecked;
        });

        ui.AddSeparator();


        ui.CreateLabel("Shadow generation technique:");
        ui.CreateRadioButtons(new string[]
            {
                "PlanarShadowNode (?): PlanarShadowNode renders the meshes from the specified SceneNodes again but the meshes are\nflattened to the plane by using the shadow matrix and rendered by the ShadowMaterial.\nThis method is very fast but does not support clipping to bounds / plane.",
                "PlanarShadowMeshCreator (?): PlanarShadowMeshCreator generates a single mesh from combining all the specified SceneNodes.\nThe mesh is already flatten and can be clipped to bounds or plane.\nThis method is much slower than PlanarShadowNode."
            },
            (selectedIndex, selectedText) =>
            {
                if (selectedIndex == 0)
                {
                    SetupPlanarShadowNode();
                    _clipCheckBox.SetIsVisible(false);
                }
                else
                {
                    SetupPlanarShadowMeshCreator();
                    _clipCheckBox.SetIsVisible(true);
                }
            }, 
            selectedItemIndex: 0);


        // Clip shadow to plane is available only when using PlanarShadowMeshCreator
        _clipCheckBox = ui.CreateCheckBox("Clip shadow to plane (?): Clipping shadow to plane is a complex operations, so if possible it is better that this is disabled.", isInitiallyChecked: true, isChecked =>
        {
            if (_planarShadowMeshCreator != null)
                _planarShadowMeshCreator.ClipToPlane = isChecked;
        }).SetIsVisible(false);

        ui.AddSeparator();
        
        
        ui.CreateLabel("Light type:");
        ui.CreateRadioButtons(new string[] { "DirectionalLight", "PointLight" },
            (selectedIndex, selectedText) => SetShadowLight(isDirectionalLight: selectedIndex == 0),
            selectedItemIndex: 0);

        ui.CreateSlider(-180, 180, () => _lightHorizontalAngle, newValue =>
        {
            _lightHorizontalAngle = newValue;
            UpdateLights();
        });
        
        ui.CreateSlider(30, 90, () => _lightVerticalAngle, newValue =>
        {
            _lightVerticalAngle = newValue;
            UpdateLights();
        });
    }
}